//#convert_panic_to_exception

type bool {
	#layout(size = 1, align = 1);

	wellknown_traits(Copy);
}

mod ::std {
	mod vec {
		// For internal use
		type Vec<::nalgebra::Vector3<f64>> {
			#layout(size = 24, align = 8);

			fn len(&self) -> usize;
			fn with_capacity(usize) -> Vec<::nalgebra::Vector3<f64>>;
			fn push(&mut self, ::nalgebra::Vector3<f64>);
			fn as_slice(&self) -> &[::nalgebra::Vector3<f64>];
		}
		type Vec<::nalgebra::Vector3<i32>> {
			#layout(size = 24, align = 8);

			fn len(&self) -> usize;
			fn with_capacity(usize) -> Vec<::nalgebra::Vector3<i32>>;
			fn push(&mut self, ::nalgebra::Vector3<i32>);
			fn as_ptr(&self) -> *const ::nalgebra::Vector3<i32>;
            fn get(&self, usize) -> ::core::option::Option<&::nalgebra::Vector3<i32>> deref [::nalgebra::Vector3<i32>];
		}
		type Vec<::nalgebra::Vector4<f64>> {
			#layout(size = 24, align = 8);

			fn len(&self) -> usize;
			fn with_capacity(usize) -> Vec<::nalgebra::Vector4<f64>>;
			fn push(&mut self, ::nalgebra::Vector4<f64>);
			fn as_ptr(&self) -> *const ::nalgebra::Vector4<f64>;
		}

		type Vec<u32> {
			#layout(size = 24, align = 8);

			fn new() -> Vec<u32>;
			fn clone(&self) -> Vec<u32>;
			fn len(&self) -> usize;
            fn get(&self, usize) -> ::core::option::Option<&u32> deref [u32];
            //fn get_mut(&mut self, usize) -> ::core::option::Option<&mut u32> deref [u32];
			fn is_empty(&self) -> bool;
			fn push(&mut self, u32);
			fn as_ptr(&self) -> *const u32;
			fn as_mut_ptr(&mut self) -> *mut u32;
			fn clear(&mut self);
			fn resize(&mut self, usize, u32);
		}

		type Vec<f32> {
			#layout(size = 24, align = 8);

			fn new() -> Vec<f32>;
			fn clone(&self) -> Vec<f32>;
			fn len(&self) -> usize;
            fn get(&self, usize) -> ::core::option::Option<&f32> deref [f32];
            //fn get_mut(&mut self, usize) -> ::core::option::Option<&mut f32> deref [f32];
			fn is_empty(&self) -> bool;
			fn push(&mut self, f32);
			fn as_ptr(&self) -> *const f32;
			fn as_mut_ptr(&mut self) -> *mut f32;
			fn clear(&mut self);
			fn resize(&mut self, usize, f32);
		}

		type Vec<u64> {
			#layout(size = 24, align = 8);

			fn new() -> Vec<u64>;
			fn clone(&self) -> Vec<u64>;
			fn len(&self) -> usize;
            fn get(&self, usize) -> ::core::option::Option<&u64> deref [u64];
            //fn get_mut(&mut self, usize) -> ::core::option::Option<&mut u64> deref [u64];
			fn is_empty(&self) -> bool;
			fn push(&mut self, u64);
			fn as_ptr(&self) -> *const u64;
			fn as_mut_ptr(&mut self) -> *mut u64;
			fn clear(&mut self);
			fn resize(&mut self, usize, u64);
		}

		type Vec<f64> {
			#layout(size = 24, align = 8);

			fn new() -> Vec<f64>;
			fn clone(&self) -> Vec<f64>;
			fn len(&self) -> usize;
            fn get(&self, usize) -> ::core::option::Option<&f64> deref [f64];
            //fn get_mut(&mut self, usize) -> ::core::option::Option<&mut f64> deref [f64];
			fn is_empty(&self) -> bool;
			fn push(&mut self, f64);
			fn as_ptr(&self) -> *const f64;
			fn as_mut_ptr(&mut self) -> *mut f64;
			fn clear(&mut self);
			fn resize(&mut self, usize, f64);
		}

		type Vec<crate::MeshBool> {
			#layout(size = 24, align = 8);

			fn len(&self) -> usize;
            fn get(&self, usize) -> ::core::option::Option<&crate::MeshBool> deref [crate::MeshBool];
		}
	}
}

mod ::core {
	mod option {
		type Option<f64> {
			#layout(size = 16, align = 8);
			wellknown_traits(Copy);

			constructor None;
			constructor Some(f64);

			fn is_some(&self) -> bool;
			fn unwrap(self) -> f64;
		}
		type Option<&f32> {
			#layout(size = 8, align = 8);
			wellknown_traits(Copy);

			fn is_some(&self) -> bool;
			fn unwrap(self) -> &f32;
		}
		type Option<&u32> {
			#layout(size = 8, align = 8);
			wellknown_traits(Copy);

			fn is_some(&self) -> bool;
			fn unwrap(self) -> &u32;
		}
		type Option<&f64> {
			#layout(size = 8, align = 8);
			wellknown_traits(Copy);

			fn is_some(&self) -> bool;
			fn unwrap(self) -> &f64;
		}
		type Option<&u64> {
			#layout(size = 8, align = 8);
			wellknown_traits(Copy);

			fn is_some(&self) -> bool;
			fn unwrap(self) -> &u64;
		}
		type Option<&::nalgebra::Vector3<i32>> {
			#layout(size = 8, align = 8);
			wellknown_traits(Copy);

			fn is_some(&self) -> bool;
			fn unwrap(self) -> &::nalgebra::Vector3<i32>;
		}
		type Option<&::nalgebra::Point2<f64>> {
			#layout(size = 8, align = 8);
			wellknown_traits(Copy);

			fn is_some(&self) -> bool;
			fn unwrap(self) -> &::nalgebra::Point2<f64>;
		}
		type Option<&::std::vec::Vec<::nalgebra::Point2<f64>>> {
			#layout(size = 8, align = 8);
			wellknown_traits(Copy);

			fn is_some(&self) -> bool;
			fn unwrap(self) -> &::std::vec::Vec<::nalgebra::Point2<f64>>;
		}
		type Option<&crate::MeshBool> {
			#layout(size = 8, align = 8);

			fn unwrap(self) -> &crate::MeshBool;
		}

		type Option<&::nalgebra::Point3<f64>> {
			#layout(size = 8, align = 8);
			wellknown_traits(Copy);

			fn is_some(&self) -> bool;
			fn unwrap(self) -> &::nalgebra::Point3<f64>;
		}
		type Option<Box<dyn Fn(&mut [f64], ::nalgebra::Point3<f64>, &[f64])>> {
			#layout(size = 16, align = 8);

			constructor None;
			constructor Some(Box<dyn Fn(&mut [f64], ::nalgebra::Point3<f64>, &[f64])>);
		}
	}
}

type [f64] {
    wellknown_traits(?Sized);

	fn as_ptr(&self) -> *const f64;
	fn as_mut_ptr(&mut self) -> *mut f64;
}

type [::nalgebra::Vector3<f64>] {
	wellknown_traits(?Sized);
}

type [::nalgebra::Point3<f64>] {
	wellknown_traits(?Sized);

	fn len(&self) -> usize;
	fn get(&self, usize) -> core::option::Option<&::nalgebra::Point3<f64>>;
	//fn get_mut(&mut self, usize) -> core::option::Option<&mut ::nalgebra::Point3<f64>> deref [::nalgebra::Point3<f64>];
}



mod ::std::slice {
	fn from_raw_parts<f64>(*const f64, usize) -> &[f64];
}

mod ::nalgebra {
	type Matrix3x4<f64> {
		#layout(size = 96, align = 8);

		fn from_column_slice(&[f64]) -> Matrix3x4<f64>;
	}

	type Matrix3<f64> {
		#layout(size = 72, align = 8);
	}

	type Vector2<f64> {
		#layout(size = 16, align = 8);

		wellknown_traits(Copy);

		fn new(f64, f64) -> Vector2<f64>;
	}

	type Vector3<i32> {
		#layout(size = 12, align = 4);

		wellknown_traits(Copy);

		fn new(i32, i32, i32) -> Vector3<i32>;

		// field name (offset = X, type = T);

		fn get_x(&self) -> i32;
		fn get_y(&self) -> i32;
		fn get_z(&self) -> i32;
	}

	type Vector3<f64> {
		#layout(size = 24, align = 8);

		wellknown_traits(Copy);

		fn new(f64, f64, f64) -> Vector3<f64>;

		// field name (offset = X, type = T);
	}

	type Vector4<f64> {
		#layout(size = 32, align = 8);

		wellknown_traits(Copy);

		fn new(f64, f64, f64, f64) -> Vector4<f64>;

		fn get_x(&self) -> f64;
		fn get_y(&self) -> f64;
		fn get_z(&self) -> f64;
		fn get_w(&self) -> f64;
	}

	type Vector4<i32> {
		#layout(size = 16, align = 4);

		wellknown_traits(Copy);

		fn new(i32, i32, i32, i32) -> Vector4<i32>;

		// field name (offset = X, type = T);

		fn get_x(&self) -> i32;
		fn get_y(&self) -> i32;
		fn get_z(&self) -> i32;
		fn get_w(&self) -> i32;
	}

	type Vector4<bool> {
		#layout(size = 4, align = 1);

		wellknown_traits(Copy);

		fn new(bool, bool, bool, bool) -> Vector4<bool>;

		// field name (offset = X, type = T);
	}

	type Point2<f64> {
		#layout(size = 16, align = 8);

		wellknown_traits(Copy);

		fn new(f64, f64) -> Point2<f64>;
		fn get_x(&self) -> f64;
		fn get_y(&self) -> f64;
	}

	type Point3<f64> {
		#layout(size = 24, align = 8);

		wellknown_traits(Copy);

		fn new(f64, f64, f64) -> Point3<f64>;
		fn get_x(&self) -> f64;
		fn get_y(&self) -> f64;
		fn get_z(&self) -> f64;
	}
}

mod ::std {
	mod vec {
		type Vec<crate::polygon::PolyVert> {
			#layout(size = 24, align = 8);
			fn len(&self) -> usize;
			fn new() -> Vec<crate::polygon::PolyVert>;
			fn push(&mut self, crate::polygon::PolyVert);
		}
		type Vec<Vec<crate::polygon::PolyVert>> {
			#layout(size = 24, align = 8);
			fn len(&self) -> usize;
			fn new() -> Vec<Vec<crate::polygon::PolyVert>>;
			fn push(&mut self, Vec<crate::polygon::PolyVert>);
		}

		type Vec<::nalgebra::Point2<f64>> {
			#layout(size = 24, align = 8);

            fn get(&self, usize) -> ::core::option::Option<&::nalgebra::Point2<f64>> deref [::nalgebra::Point2<f64>];
			fn len(&self) -> usize;
			fn new() -> Vec<::nalgebra::Point2<f64>>;
			fn push(&mut self, ::nalgebra::Point2<f64>);
		}
		type Vec<Vec<::nalgebra::Point2<f64>>> {
			#layout(size = 24, align = 8);

            fn get(&self, usize) -> ::core::option::Option<&Vec<::nalgebra::Point2<f64>>> deref [Vec<::nalgebra::Point2<f64>>];
			fn len(&self) -> usize;
			fn new() -> Vec<Vec<::nalgebra::Point2<f64>>>;
			fn push(&mut self, Vec<::nalgebra::Point2<f64>>);
		}
	}
}

type Box<dyn Fn(&mut [f64], ::nalgebra::Point3<f64>, &[f64])> {
	#layout(size = 16, align = 8);
}

type Box<dyn Fn(&mut ::nalgebra::Point3<f64>)> {
	#layout(size = 16, align = 8);
}

type Box<dyn Fn(&mut [::nalgebra::Point3<f64>])> {
	#layout(size = 16, align = 8);
}

mod crate {
	mod polygon {
		type PolyVert {
			#layout(size = 24, align = 8);
			field pos (offset = 0, type = ::nalgebra::Point2<f64>);
			field idx (offset = 16, type = i32);

			fn new(::nalgebra::Point2<f64>, i32) -> PolyVert;
		}
		fn triangulate_idx(
			&::std::vec::Vec<::std::vec::Vec<PolyVert>>,
			f64,
			bool
		) -> ::std::vec::Vec<::nalgebra::Vector3<i32>>;
		fn triangulate(
			&::std::vec::Vec<::std::vec::Vec<::nalgebra::Point2<f64>>>,
			f64,
			bool
		) -> ::std::vec::Vec<::nalgebra::Vector3<i32>>;
	}
	type MeshBool {
		#layout(size = 320, align = 8);

		fn default() -> MeshBool;
		fn simplify(&self, ::core::option::Option<f64>) -> MeshBool;
		fn genus(&self) -> usize;
		fn surface_area(&self) -> f64;
		fn volume(&self) -> f64;
		fn original_id(&self) -> i32;
		fn tetrahedron() -> MeshBool;
		fn cube(::nalgebra::Vector3<f64>, bool) -> MeshBool;
		fn cylinder(
			f64,
			f64,
			f64,
			u32,
			bool,
		) -> MeshBool;
		fn sphere(f64, i32) -> MeshBool;
		fn extrude(
			&::std::vec::Vec<::std::vec::Vec<::nalgebra::Point2<f64>>>,
			f64,
			u32,
			f64,
			::nalgebra::Vector2<f64>,
		) -> MeshBool;
		fn revolve(
			&::std::vec::Vec<::std::vec::Vec<::nalgebra::Point2<f64>>>,
			i32,
			f64,
		) -> MeshBool;
		fn decompose(&self) -> ::std::vec::Vec<MeshBool>;
		fn as_original(&self) -> MeshBool;
		fn reserve_ids(u32) -> u32;
		fn matches_tri_normals(&self) -> bool;
		fn num_degenerate_tris(&self) -> usize;
		fn translate(&self, ::nalgebra::Vector3<f64>) -> MeshBool;
		fn scale(&self, ::nalgebra::Vector3<f64>) -> MeshBool;
		fn rotate(&self, f64, f64, f64) -> MeshBool;
		fn transform(&self, &::nalgebra::Matrix3x4<f64>) -> MeshBool;
		fn mirror(&self, ::nalgebra::Vector3<f64>) -> MeshBool;
		fn warp(&self, Box<dyn Fn(&mut ::nalgebra::Point3<f64>)>) -> MeshBool;
		fn warp_batch(&self, Box<dyn Fn(&mut [::nalgebra::Point3<f64>])>) -> MeshBool;
		fn set_properties(
			&self,
			i32,
			::core::option::Option<Box<dyn Fn(&mut [f64], ::nalgebra::Point3<f64>, &[f64])>>,
		) -> MeshBool;
		fn calculate_curvature(&self, i32, i32) -> MeshBool;
		fn calculate_normals(&self, i32, f64) -> MeshBool;
		fn refine(&self, i32) -> MeshBool;
		fn refine_to_length(&self, f64) -> MeshBool;
		fn refine_to_tolerance(&self, f64) -> MeshBool;
		fn boolean(&self, &MeshBool, OpType) -> MeshBool;
		fn split(&self, &MeshBool) -> (MeshBool, MeshBool);
		fn split_by_plane(&self, ::nalgebra::Vector3<f64>, f64) -> (MeshBool, MeshBool);
		fn trim_by_plane(&self, ::nalgebra::Vector3<f64>, f64) -> MeshBool;
		fn slice(&self, f64) -> ::std::vec::Vec<::std::vec::Vec<::nalgebra::Point2<f64>>>;
		fn get_mesh_gl(&self, i32) -> MeshGL;
		fn get_mesh_gl64(&self, i32) -> MeshGL64;
		fn from_meshgl(&MeshGL) -> MeshBool;
		fn from_meshgl64(&MeshGL64) -> MeshBool;
		fn is_empty(&self) -> bool;
		fn status(&self) -> ManifoldError;
		fn num_vert(&self) -> usize;
		fn num_edge(&self) -> usize;
		fn num_tri(&self) -> usize;
		fn num_prop(&self) -> usize;
		fn num_prop_vert(&self) -> usize;
		fn bounding_box(&self) -> AABB;
		fn get_epsilon(&self) -> f64;
		fn get_tolerance(&self) -> f64;
		fn set_tolerance(&self, f64) -> MeshBool;
		fn project(&self) -> ::std::vec::Vec<::std::vec::Vec<::nalgebra::Point2<f64>>>;
		fn min_gap(&self, &MeshBool, f64) -> f64;

		fn clone(&self) -> MeshBool;
	}
	type (MeshBool, MeshBool) {
		#layout(size = 640, align = 8);

		field 0 (offset = 0, type = MeshBool);
		field 1 (offset = 320, type = MeshBool);
	}

	type MeshGL {
		#layout(size = 200, align = 8);

		fn default() -> MeshGL;
		fn clone(&self) -> MeshGL;

		fn num_vert(&self) -> u32;
		fn num_tri(&self) -> u32;

		//field name (offset = X, type = T);
		field num_prop (offset = 192, type = u32);
		field vert_properties (offset = 0, type = ::std::vec::Vec<f32>);
		field tri_verts (offset = 24, type = ::std::vec::Vec<u32>);
		field merge_from_vert (offset = 48, type = ::std::vec::Vec<u32>);
		field merge_to_vert (offset = 72, type = ::std::vec::Vec<u32>);
		field run_index (offset = 96, type = ::std::vec::Vec<u32>);
		field run_original_id (offset = 120, type = ::std::vec::Vec<u32>);
		field run_transform (offset = 144, type = ::std::vec::Vec<f32>);
		field face_id (offset = 168, type = ::std::vec::Vec<u32>);
		field tolerance (offset = 196, type = f32);

		fn merge(&mut self) -> bool;
	}

	type MeshGL64 {
		#layout(size = 208, align = 8);

		fn default() -> MeshGL64;
		fn clone(&self) -> MeshGL64;

		fn num_vert(&self) -> u64;
		fn num_tri(&self) -> u64;

		//field name (offset = X, type = T);
		field num_prop (offset = 192, type = u64);
		field vert_properties (offset = 0, type = ::std::vec::Vec<f64>);
		field tri_verts (offset = 24, type = ::std::vec::Vec<u64>);
		field merge_from_vert (offset = 48, type = ::std::vec::Vec<u64>);
		field merge_to_vert (offset = 72, type = ::std::vec::Vec<u64>);
		field run_index (offset = 96, type = ::std::vec::Vec<u64>);
		field run_original_id (offset = 120, type = ::std::vec::Vec<u32>);
		field run_transform (offset = 144, type = ::std::vec::Vec<f64>);
		field face_id (offset = 168, type = ::std::vec::Vec<u64>);
		field tolerance (offset = 200, type = f64);

		fn merge(&mut self) -> bool;
	}

	type AABB {
		#layout(size = 48, align = 8);

		wellknown_traits(Copy);

		field min (offset = 0, type = ::nalgebra::Point3<f64>);
		field max (offset = 24, type = ::nalgebra::Point3<f64>);
	}

	type OpType {
		#layout(size = 1, align = 1);

		wellknown_traits(Copy);

		constructor Add;
		constructor Subtract;
		constructor Intersect;
	}

	type ManifoldError {
		#layout(size = 1, align = 1);

		wellknown_traits(Copy);

		constructor NoError;
		constructor NonFiniteVertex;
		constructor InvalidConstruction;
		constructor ResultTooLarge;
		constructor NotManifold;
		constructor MissingPositionProperties;
		constructor MergeVectorsDifferentLengths;
		constructor TransformWrongLength;
		constructor RunIndexWrongLength;
		constructor FaceIDWrongLength;
		constructor MergeIndexOutOfBounds;
		constructor VertexOutOfBounds;

		fn is_no_error(&self) -> bool;
		fn is_non_finite_vertex(&self) -> bool;
		fn is_invalid_construction(&self) -> bool;
		fn is_result_too_large(&self) -> bool;
		fn is_not_manifold(&self) -> bool;
		fn is_missing_position_properties(&self) -> bool;
		fn is_merge_vectors_different_lengths(&self) -> bool;
		fn is_transform_wrong_length(&self) -> bool;
		fn is_run_index_wrong_length(&self) -> bool;
		fn is_face_id_wrong_length(&self) -> bool;
		fn is_merge_index_out_of_bounds(&self) -> bool;
		fn is_vertex_out_of_bounds(&self) -> bool;
	}
	// TMP
	mod utils {
		fn ccw(::nalgebra::Point2<f64>, ::nalgebra::Point2<f64>, ::nalgebra::Point2<f64>, f64) -> i32;
		fn mat3(&::nalgebra::Matrix3x4<f64>) -> ::nalgebra::Matrix3<f64>;
	}
	// For internal use
	mod tri_dis {
		fn distance_triangle_triangle_squared(&[::nalgebra::Vector3<f64>], &[::nalgebra::Vector3<f64>]) -> f64;
	}

	mod subdivision {
		type Partition {
			#layout(size = 80, align = 8);

			field idx (offset = 48, type = ::nalgebra::Vector4<i32>);
			field sorted_divisions (offset = 64, type = ::nalgebra::Vector4<i32>);
			field vert_bary (offset = 0, type = ::std::vec::Vec<::nalgebra::Vector4<f64>>);
			field tri_vert (offset = 24, type = ::std::vec::Vec<::nalgebra::Vector3<i32>>);

			fn interior_offset(&self) -> i32;
			fn num_interior(&self) -> i32;
			fn get_partition(::nalgebra::Vector4<i32>) -> Partition;
			fn reindex(
				&self,
				::nalgebra::Vector4<i32>,
				::nalgebra::Vector4<i32>,
				::nalgebra::Vector4<bool>,
				i32,
			) -> ::std::vec::Vec<::nalgebra::Vector3<i32>>;
		}
	}
}
